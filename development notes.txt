Each investment period is a node. The first investment period will be the root node of the scenario tree. It will have one child node for the next investment period and multiple child nodes for dispatch scenarios that could occur within that period. 

In the scenario tree, I need to be able to write stuff like:
set StageVariables[Invest_Stage1] := BuildProjects[Period1,*] RetireExistingPlant[Period1,*] BuildTrans[Period1, *] ...
set StageVariables[Dispatch_Stage1a] := DispatchGen[Scenario1a,*,*]  DispatchTrans[Scenario1a,*,*]  DispatchStorage[Scenario1a,*,*] ...
This duplicates information in the indexes since each timepoint is uniquely associated with a single period, but adding the period indexes will enable much simpler specification of problem stages. I'm currently thinking that stages will progress: Invest1, Dispatch1a, Dispatch1b, Invest2, Dispatch2a, Dispatch2b, ..., Invest-n, Dispatch-n

2/17 PM & 2/18 AM. 
I'm trying to structure and document the code as I go for maximal readability. I still haven't settled on a package/module structure and I will most likely reorganize as I proceed and learn more about python. Right now, I'm aiming for different files to contain python functions that add define major chunks of the switch model. timescales.py is the first of these files. 
I looked into python autodocumentation packages and started using pydoc to get started. I think Sphinx would be better eventually, but that has a bit more set-up and learning to it. Hopefully it won't be too hard to transition text from basic pydoc format (multi-line comments at the beginning of files, functions or classes) to whatever Sphinx prefers. As part of this autodoc effort, I moved most of the inline comments to the multi-line comments. That actually makes the code cleaner and easier to read, in my opinion. 
As I was trying to figure out if pydoc supported any simple markup (it doesn't), I ran into doctest. It's a simple framework that will look for any example code snippets and expected output in the multi-line comments (same ones that pydoc examines). Whatever it finds, it executes and compares literal output to expected output. It's clean and simple, but not terribly scalable. Unittest is the scalable version, but that has a little more learning curve to it, so I'm punting on that for the moment. doctest can integrate with unittest, so whatever simple tests I do with doctest can be re-used later. Anyway, to take advantage of doctest, I merged the contents of the test_timescales() with the SYNOPSIS section. I wrote two more data files that should fail in different ways, but those aren't as appropriate for doctest because part of the error messages include library paths that are specific to my system. Oh well. 

